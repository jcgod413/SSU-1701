# 문제해결
2017년 3월 22일
작성자 : DH Kim
## 0-1 Knapsack Problem
### Problem
- S = {item_1,item_2,...,item_n}
- w_i = item_i의 무게
- p_i = item_i의 가치
- W = 배낭에 넣을 수 있는 최대 무게라고 할 때, 최대 무게를 넘지 않으면서 가치의 합이 최대가 되도록 결정하는 문제

### 물건의 일부분을 잘라서 담을 수 있는 경우
- 그리디 알고리즘을 활용하여 최적해를 구할 수 있다.
- 무게 당 가치가 가장 노은 물건부터 우선적으로 채운다.

### 물건의 일부분을 잘라서 담을 수 없는 경우
- 무게당 가치가 가장 높은물건부터 우선적으로 채운다?
  - 항상 최적의 해를 주지는 않는다
- 가장 비싼물건부터 우선적으로 채운다?
  - 이방법도 최적의 해가 아님
- 무작정 알고리즘
  - 2^n의 시간복잡도가 필요
- Dynamic Programming Approach
  - P[i][w] = {1, ..., i}고려해서 무게합 <=w 최대가치
  -  i -> 0~n
  - w -> 0~W
  - i번째 항목중에 얻어진 최고의 이익을 p[i][w]라고 하면
    <div align=center><img src="img/knap1.png" /></div>

---

## Chained Matrix Multiplication(연쇄 행렬 곱셈)

- 곱셈의 횟수가 가장 적은 알고리즘을 구하는 것이 목표
  ```
  A_1 * A_2 * A_3
  A_1 :10*100, A_2 : 100*5, A_3 : 5*50
  (A_1 * A_2) * A_3 = 7500회
  A_1 * (A_2 * A_3) = 75000회
  ```  

- A_1 * A_2 * ... * A_i * ... * A_j * ... * A_n
  `M[i][j] : A_i~A_j 최소 곱셈 횟수`

  `i<=k<=j-1`
  ```
  M[i][j] := M[i][k]+M[k+1][j] d_(i-1) * d_k * d_j
  ```
